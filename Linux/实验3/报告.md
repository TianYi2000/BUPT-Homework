# 《Linux开发环境及应用》第三次作业

# 目录

[TOC]

<div style="page-break-after:always"></div>

# 第一题：生成TCP活动状况报告

## 一、实验题目

生成TCP活动状况报告



## 二、实验要求

`netstat --statistics` 命令可以列出tcp等协议的统计信息。编写shell脚本程序，每隔1分钟生成1行信息：当前时间；这一分钟内TCP发送了多少报文；接收了多少报文；收发报文总数；行尾给出符号+或-或空格（+表示这分钟收发报文数比上分钟多10包以上，差别在10包或以内用空格，否则用符号-）。运行示例如下：

```
2018-05-17 00:02   345   314   659     
2018-05-17 00:03  1252  1100  2352     +
2018-05-17 00:04   714   570  1284     -
2018-05-17 00:05   151   139   290     -
2018-05-17 00:06  1550  1097  2647     +
2018-05-17 00:07  1385   959  2344     -
2018-05-17 00:08     5     1     6     -
2018-05-17 00:09     5     1     6     
2018-05-17 00:10   837   723  1560     +
2018-05-17 00:11    22    22    44     -
```



1. 文件尽量命名为 学号-姓名-第几次作业，多个文件时候尽量提交一个压缩包
2. 报告内容尽量充实，不要简单贴上代码，截几张图，代码可以贴在报告最后

<div style="page-break-after:always"></div>

## 三、程序流程图

![total](C:\Users\HTY\iCloudDrive\iCloud~QReader~MarginStudy\Linux开发环境及应用\实验\实验3\total.svg)

<div style="page-break-after:always"></div>

## 四、实验步骤

### 1 校准时间

由于我们要统计的是每分钟内的收、发报文数，显然将统计的时刻放在每分钟的末尾是合理的。这里我们设计`wait_until_next58s`函数，等待直至下一个58秒；这之后再以60秒的循环运行程序，便会在每个分钟的第58秒进行统计。

```
wait_until_next58s()
{
	eval $(date +'second=%S;')
	if [ $(expr $second) -gt 58 ]
	then
		wait_t=$(expr 118 - $second)
	else
		wait_t=$(expr 58 - $second)
	fi
	sleep $wait_t
}
```



### 2 获取报文数值

观察`netstat --statistics` 的运行结果，可以得知收到报文数的数据在：

```
34709391 segments received
```

该行的第一列数据中



发送报文数的数据在：

```
36722435 segments sent out
```

该行的第一列数据中

![image-20210516143746488](C:\Users\HTY\AppData\Roaming\Typora\typora-user-images\image-20210516143746488.png)

通过awk将后几列的数据拼接起来进行查找，查到的行的第一列数据便是我们需要的报文数

```
recv=$(netstat --statistics | awk '$2$3~/segmentsreceived/{print $1}')
send=$(netstat --statistics | awk '$2$3$4~/segmentssentout/{print $1}')
```



同时，要记得在抓取报文数前更新上一分钟报文数`pre_recv`、`pre_send`

```
get_netstat()
{
	pre_recv=$recv
	pre_send=$send
	recv=$(netstat --statistics | awk '$2$3~/segmentsreceived/{print $1}')
	send=$(netstat --statistics | awk '$2$3$4~/segmentssentout/{print $1}')
}
```



### 3 计算差值

当前分钟数据与上一分钟数据作差即可

```
cal_delta()
{
	get_netstat
	d_recv=$(expr $recv - $pre_recv)
	d_send=$(expr $send - $pre_send)
	pre_total=$total
	total=$(expr $d_send + $d_recv)
}
```



### 4 判断变化

计算`$total - $pre_total`，大于10说明行尾符号为`+`，小于-10说明行尾符号为`-`， 二者都不是即为空格

这里需要注意的是，输出结果中，第一行行尾符号必为空格，这里我在初始化时特殊处理了

```
judge_change()
{
	if [ $(expr $total - $pre_total) -gt 10 ]
	then
		End='+'
	elif [ $(expr $pre_total - $total) -gt 10 ]
	then
		End='-'
	else
		End=' '
	fi
}
```



### 5 获取时间

获取当前完整时间，用于打印

```
get_time()
{
	time=$(date +"%F %H:%M")
}
```



### 6 打印结果

格式化打印统计结果

```
print_result()
{
	printf "%-20s%-6s%-6s%-6s%-6s\n" "$time" "$d_recv" "$d_send" "$total" "$End"
}
```



### 7 初始化

初始化除了进行校准时间操作外，有一个要注意的点就是，输出结果中第一行尾符号必为空格，这里我直接先进行一次统计，并限定行尾符号为空格

```
init()
{
	wait_until_next58s
	get_netstat
	sleep 60
	cal_delta
	End=' '
	get_time
	print_result
}
```



### 8 循环

正式循环在初始化后开始，循环体内操作为

1. 等待60s
2. 获取时间
3. 计算差值（该函数内包含对报文数值的获取）
4. 判断变化
5. 打印结果

```
while true
do
	sleep 60
	get_time
	cal_delta
	judge_change
	print_result
done
```

<div style="page-break-after:always"></div>

## 五、完整代码

```
#!/bin/bash
get_time()
{
	time=$(date +"%F %H:%M")
}
wait_until_next58s()
{
	eval $(date +'second=%S;')
	if [ $(expr $second) -gt 58 ]
	then
		wait_t=$(expr 118 - $second)
	else
		wait_t=$(expr 58 - $second)
	fi
	sleep $wait_t
}
get_netstat()
{
	pre_recv=$recv
	pre_send=$send
	recv=$(netstat --statistics | awk '$2$3~/segmentsreceived/{print $1}')
	send=$(netstat --statistics | awk '$2$3$4~/segmentssentout/{print $1}')
}
cal_delta()
{
	get_netstat
	d_recv=$(expr $recv - $pre_recv)
	d_send=$(expr $send - $pre_send)
	pre_total=$total
	total=$(expr $d_send + $d_recv)
}
judge_change()
{
	if [ $(expr $total - $pre_total) -gt 10 ]
	then
		End='+'
	elif [ $(expr $pre_total - $total) -gt 10 ]
	then
		End='-'
	else
		End=' '
	fi
}
init()
{
	wait_until_next58s
	get_netstat
	sleep 60
	cal_delta
	End=' '
	get_time
	print_result
}
print_result()
{
	printf "%-20s%-6s%-6s%-6s%-6s\n" "$time" "$d_recv" "$d_send" "$total" "$End"
}
init
while true
do
	sleep 60
	get_time
	cal_delta
	judge_change
	print_result
done
```

<div style="page-break-after:always"></div>

## 六、实验结果

![image-20210511152653079](C:\Users\HTY\AppData\Roaming\Typora\typora-user-images\image-20210511152653079.png)

```
a0547@Ubuntu-bupt:~/lab3$ ./a.sh 
2021-05-11 15:12    613   540   1153        
2021-05-11 15:13    509   532   1041  -     
2021-05-11 15:14    500   515   1015  -     
2021-05-11 15:15    425   436   861   -     
2021-05-11 15:16    457   468   925   +     
2021-05-11 15:17    457   480   937   +     
2021-05-11 15:18    451   476   927         
2021-05-11 15:19    670   670   1340  +     
2021-05-11 15:20    601   601   1202  -     
2021-05-11 15:21    628   648   1276  +     
2021-05-11 15:22    397   409   806   -     
2021-05-11 15:23    442   460   902   +
```

<div style="page-break-after:always"></div>

# 第二题：下载bing图库中图片

## 一、实验题目

访问https://bing.ioliu.cn/?p=23可以看到bing图库第23页的内容（见下一PPT中的图片），这个Web页有多个图片小样，将鼠标放到某个小样上，如右上角，可见中文说明信息
“野花草甸上的一只欧亚雕鸮，德国莱茵兰-普法尔茨”和日期信息2019-08-03，点击一下，此图片就可以下载。
编写脚本程序bing.sh，将这个图库中照片全部下载下来存放到本地bing目录中，上面URL中p=23可以换成p=1到p=126可访问126个页，每页有12个图，每个图的日期，中文说明信息和下载地址及文件名html文件中可提取。要求下载后的文件命名为“日期 中文说明.jpg”例如：2019-08-03 野花草甸上的一只欧亚雕鸮，德国莱茵兰-普法尔茨.jpg



## 二、实验要求

- 命令行参数
  - `./bing.sh` 后面可以跟两个参数，通过指定页号区间限定下载范围，没有参数时页号区间为1-126
  - 要允许多个程序并发，例如：一个终端上启动 `./bing.sh 1 63` ，另一个终端上启动 `./bing.sh 64 126` ，这样在两个终端上同时下载，以加快任务完成的速度。
- 不重复下载已下载的图片
  - 检查图片是否已下载，如果已下载，则不再下载，这样在一定程度上支持批量任务在被中断后可以从断点继续
- 考虑下载文件出现故障的情况
  - 如果一个图片有5MB，接收1.5MB后网络断开，则残存一个不完整的图片文件。避免这种现象发生的一种方法是，wget下载时使用一个临时文件名。判断wget是否成功 ，若成功则将文件改名为正式名称；若失败，删除临时文件。临时文件名的选取要考虑前述的并发问题，至少不可以固定一个名字导致两进程的争夺。

**选作**

- 获取更多图片
  对已设计好的bing.sh进一步扩充，允许下面的命令行参数：

  ```
  ./	bing.sh rand 500
  ```

  实现的功能为：执行500次随机获取。每次成功的随机获取会得到一个图片，检查一下这个图片是否本地已存在。如果已存在，丢弃，否则保存。
  访问https://bing.ioliu.cn/v1/rand?type=json可得到一个json数据，每次得到的内容是随机的，其中含有图片的日期、说明信息和获取它的url网址。新获得的文件命名方式与以前的程序相同。要求：文件名不同但是内容完全相同的图片丢弃，例如，下面两个文件虽然名字不同，但是内容是一样的，只保留其中一个文件。

  ```
  2019-05-03 Ruff male displaying its plumage, Varanger Peninsula, Norway.jpg
  2019-05-02 挪威瓦朗厄尔半岛上一只展示翎颌的雄性涉禽.jpg
  ```

 <div style="page-break-after:always"></div>

## 三、程序流程图

![total2](C:\Users\HTY\iCloudDrive\iCloud~QReader~MarginStudy\Linux开发环境及应用\实验\实验3\total2.svg)

<div style="page-break-after:always"></div>

## 四、实验步骤

### 1 创建目录

设计`touch_dir dir`函数，传入一个目录名，判断目录是否存在，不存在则创建。

```
touch_dir()
{
	if [ ! -d  $1 ]
	then
		mkdir $1
	fi
}
```

程序初始化时运行

```
touch_dir index_html
touch_dir detail_html
touch_dir bing
touch_dir tmp
```

其中：

- `index_html` 存储目录页面
- `detail_html` 存储图片详细页面
- `tmp` 存储获取到的图片临时文件
- `bing` 存储获取到的图片正式文件



### 2 参数处理

分别考虑无参数、rand与次数参数、指定起止页码参数、错误参数的情况

```
if [ $# = 2 ]
then
	if [ $1 = 'rand' ]
	then
		rand_loop $2
	fi
	START=$1
	END=$2
elif [ $# = 0 ]
then
	START=1
	END=126
else
	echo "Usage: $0 <begin> <end> | $0 rand <times>"
	exit 1
fi
```



### 3 处理目录页面

目录页面的地址为：

```
$Root_url/?p=$index
```

其中，`Root_url='bing.ioliu.cn'`，`index` 为1-126的整数

获取到目录页面后，重命名为`index$index.html`，存储在`index_html`目录下

```
wget "$index_url" -O "index_html/index$index.html"
```

查看目录页面，找到图片详细页面url、图片描述、图片日期

![image-20210516165205076](C:\Users\HTY\AppData\Roaming\Typora\typora-user-images\image-20210516165205076.png)

先将`><`替换为换行

```
cat index_html/index$index.html | sed -e 's/></\n/g'
```

以`mark`为定位符，找到图片详细页面url、图片描述、图片日期

![image-20210516165403524](C:\Users\HTY\AppData\Roaming\Typora\typora-user-images\image-20210516165403524.png)

编写awk文件 `fetch.awk`

```
BEGIN {pos = -999;}
{Line[NR] = $0;}
/class=\"mark\"/ {pos = NR;}
NR == pos + 7 {
	printf ("%s|%s|%s\n",Line[pos],Line[pos+3],$0);
}
```

打印mark下的几行

```
cat index1.html | sed -e 's/></\n/g' | awk -f fetch.awk
```

![image-20210516165632625](C:\Users\HTY\AppData\Roaming\Typora\typora-user-images\image-20210516165632625.png)



去除掉无用字符：

```
cat index1.html | sed -e 's/></\n/g' | awk -f fetch.awk | sed 's/^.*href=\"\([^"]*\)\"|/\1 /g' | sed 's/h3>\([^ ]*\).*|/\1 /g' | sed 's/em class="t">\(.*\)<.*/\1/g'
```

![image-20210516165833720](C:\Users\HTY\AppData\Roaming\Typora\typora-user-images\image-20210516165833720.png)



将提取出的图片列表保存为`fetched_index$index.html`，之后逐行读取，作为参数传入`get_img`进行处理



```
for index in $(seq $START $END)
do
	index_url=$Root_url/?p=$index
	wget "$index_url" -O "index_html/index$index.html"
	cat index_html/index$index.html | sed -e 's/></\n/g' | awk -f fetch.awk > \
		index_html/fetched_index$index.html

	while read line
	do
		Clean_line=$(echo "${line}" | sed 's/^.*href=\"\([^"]*\)\"|/\1 /g' | \
			sed 's/h3>\([^ ]*\).*|/\1 /g' | sed 's/em class="t">\(.*\)<.*/\1/g')
		get_img $Clean_line
	done < index_html/fetched_index$index.html	
```



### 4 处理详细图片页面

查看详细图片页面，找到图片文件url定位符`data-progressive`

![image-20210516170255945](C:\Users\HTY\AppData\Roaming\Typora\typora-user-images\image-20210516170255945.png)

利用awk定位url所在行，再用sed正则匹配提取出url

```
cat '2021-03-30 春日里的荚果蕨细节图，华盛顿州.jpg.html' | awk '/data-progressive/ {print $0}' | sed 's/.*data-progressive="\(.*\)?imageslim.*/\1/g'
```

提取结果：

![image-20210516170728644](C:\Users\HTY\AppData\Roaming\Typora\typora-user-images\image-20210516170728644.png)



通过拼接字符串得到文件名

```
File_name="$Date $Discribe.jpg"
```

判断bing目录是否存在同名文件

```
if [ ! -f "bing/$File_name" ]
```

如果不存在，才使用wget获取图片文件，存入tmp目录

执行完wget后，考虑下载文件出现故障的情况，可以通过`[ $? = 0 ]` 判断wget是否成功。其中，`$?` 代表上一次执行命令的返回值，是0表示成功，非0表示失败。如果wget成功了，我们才将刚才存入tmp的临时文件移到bing目录。

由于上述过程中，详细图片页面文件、图片临时文件、图片正式文件都是以`日期 图片描述`加上不同后缀构成的，不同图片必定不相同，因此可以很好地支持



编写完整代码

```
get_img()
{
	Url=$Root_url$1
	Discribe=$2
	Date=$3
	File_name="$Date $Discribe.jpg"
	wget "$Url" -O "detail_html/$File_name.html"
	Url_img=$(cat "detail_html/$File_name.html" | awk '/data-progressive/ {print $0}' | \
		sed 's/.*data-progressive="\(.*\)?imageslim.*/\1/g')
	if [ ! -f "bing/$File_name" ]
	then
		wget "$Url_img" -O "tmp/$File_name"
		if [ $? = 0 -a ! -f "bing/$File_name" ]
		then
			mv "tmp/$File_name" "bing/$File_name"
		else
			rm "tmp/$File_name"
		fi
	fi
}
```



### 5 随机获取图片

在随机获取图片，通过访问https://bing.ioliu.cn/v1/rand?type=json可得到一个json数据，每次得到的内容是随机的，其中含有图片的日期、说明信息和获取它的url网址。

查看获取到的json数据：

![image-20210516171609856](C:\Users\HTY\AppData\Roaming\Typora\typora-user-images\image-20210516171609856.png)

提取url、描述、日期：

```
cat "rand$i.html" | sed "s/,\"/\n/g" | sed "s/\":\"/ /g" | sed "s/\"//g" | sed "s/{/\n/g" | sed "s/(.*//g" | awk -f fetch_rand.awk
```

fetch_rand.awk为：

```
/enddate/ {printf ("%s-%s-%s ", substr($2,1,4), substr($2, 5, 2), substr($2, 7, 2));}
/url/ {printf ("%s ", $2);}
/copyright/ {printf ("%s", $2); for (i=3;i<=NF;i++) printf (" %s", $i);}
```



得到结果：

![image-20210516171801921](C:\Users\HTY\AppData\Roaming\Typora\typora-user-images\image-20210516171801921.png)



其余部分与顺序获取图片的区别不大，只不过在判断重复时要加上图片内容的判断，可以使用`diff`命令

```
for file in bing/*
do
	diff "tmp/$File_name" "$file" > /dev/null
	if [ $? == 0 ]
	then
		Exist=1
		break
	fi	
done
if [ $Exist = 0 ]
then
	cp "tmp/$File_name" "bing/$File_name"
fi
```

 diff 命令返回值为 0，说明两个文件相同， 否则两个文件不相同，用`$?`获取diff命令返回值



完整代码：

```
get_img_rand()
{
	Date=$1
	Url=$2
	Discribe=""
	for i in $(seq 3 $#)
	do
		Discribe="$Discribe ${!i}"
	done
	File_name="$Date $Discribe.jpg"
	Exist=0
	wget "$Url" -O "tmp/$File_name"
	if [ $? = 0 ]
	then
		for file in bing/*
		do
			diff "tmp/$File_name" "$file" > /dev/null
			if [ $? == 0 ]
			then
				Exist=1
				break
			fi	
		done
		if [ $Exist = 0 ]
		then
			cp "tmp/$File_name" "bing/$File_name"
		fi
	fi
	rm "tmp/$File_name"
}

rand_loop()
{
	for i in $(seq $1)
	do
		wget "https://bing.ioliu.cn/v1/rand?type=json" -O "rand$i.html"
		args=$(cat "rand$i.html" | sed "s/,\"/\n/g" | sed "s/\":\"/ /g" | sed "s/\"//g" | \
			sed "s/{/\n/g" | sed "s/(.*//g" | awk -f fetch_rand.awk)
		get_img_rand $args
		sleep 0.5
	done
	exit 0
}
```

<div style="page-break-after:always"></div>

## 五、完整代码

```
#!/bin/bash
Root_url='bing.ioliu.cn'

touch_dir()
{
	if [ ! -d  $1 ]
	then
		mkdir $1
	fi
}

get_img()
{
	Url=$Root_url$1
	Discribe=$2
	Date=$3
	File_name="$Date $Discribe.jpg"
	wget "$Url" -O "detail_html/$File_name.html"
	Url_img=$(cat "detail_html/$File_name.html" | awk '/data-progressive/ {print $0}' | \
		sed 's/.*data-progressive="\(.*\)?imageslim.*/\1/g')
	if [ ! -f "bing/$File_name" ]
	then
		wget "$Url_img" -O "tmp/$File_name"
		if [ $? = 0 -a ! -f "bing/$File_name" ]
		then
			mv "tmp/$File_name" "bing/$File_name"
		else
			rm "tmp/$File_name"
		fi
	fi
}

get_img_rand()
{
	Date=$1
	Url=$2
	Discribe=""
	for i in $(seq 3 $#)
	do
		Discribe="$Discribe ${!i}"
	done
	File_name="$Date $Discribe.jpg"
	Exist=0
	wget "$Url" -O "tmp/$File_name"
	if [ $? = 0 ]
	then
		for file in bing/*
		do
			diff "tmp/$File_name" "$file" > /dev/null
			if [ $? == 0 ]
			then
				Exist=1
				break
			fi	
		done
		if [ $Exist = 0 ]
		then
			cp "tmp/$File_name" "bing/$File_name"
		fi
	fi
	rm "tmp/$File_name"
}

rand_loop()
{
	for i in $(seq $1)
	do
		wget "https://bing.ioliu.cn/v1/rand?type=json" -O "rand$i.html"
		args=$(cat "rand$i.html" | sed "s/,\"/\n/g" | sed "s/\":\"/ /g" | sed "s/\"//g" | \
			sed "s/{/\n/g" | sed "s/(.*//g" | awk -f fetch_rand.awk)
		get_img_rand $args
		sleep 0.5
	done
	exit 0
}


touch_dir index_html
touch_dir detail_html
touch_dir bing
touch_dir tmp

if [ $# = 2 ]
then
	if [ $1 = 'rand' ]
	then
		rand_loop $2
	fi
	START=$1
	END=$2
elif [ $# = 0 ]
then
	START=1
	END=126
else
	echo "Usage: $0 <begin> <end> | $0 rand <times>"
	exit 1
fi


for index in $(seq $START $END)
do
	index_url=$Root_url/?p=$index
	wget "$index_url" -O "index_html/index$index.html"
	cat index_html/index$index.html | sed -e 's/></\n/g' | awk -f fetch.awk > \
		index_html/fetched_index$index.html

	while read line
	do
		Clean_line=$(echo "${line}" | sed 's/^.*href=\"\([^"]*\)\"|/\1 /g' | \
			sed 's/h3>\([^ ]*\).*|/\1 /g' | sed 's/em class="t">\(.*\)<.*/\1/g')
		get_img $Clean_line
	done < index_html/fetched_index$index.html	
	
done

```

<div style="page-break-after:always"></div>

## 六、实验结果

### 避免重复爬取

第一次爬取页面1的图片：

![image-20210516164344075](C:\Users\HTY\AppData\Roaming\Typora\typora-user-images\image-20210516164344075.png)

看到同时爬取了图片详细页面（`filename.jpg.html`）与图片（`filename.jpg`）

第二次爬取页面1的图片：

![image-20210516164520106](C:\Users\HTY\AppData\Roaming\Typora\typora-user-images\image-20210516164520106.png)

看到只爬取了图片详细页面（`filename.jpg.html`），而不爬取图片文件（`filename.jpg`）



### 并发爬取

![image-20210516115939868](C:\Users\HTY\AppData\Roaming\Typora\typora-user-images\image-20210516115939868.png)

同时获取1-2页与3-4页的图片

![image-20210516120129237](C:\Users\HTY\AppData\Roaming\Typora\typora-user-images\image-20210516120129237.png)



### 随机爬取

![image-20210516115707258](C:\Users\HTY\AppData\Roaming\Typora\typora-user-images\image-20210516115707258.png)

![image-20210516115559572](C:\Users\HTY\AppData\Roaming\Typora\typora-user-images\image-20210516115559572.png)



### 查看图片文件

![image-20210516172607737](C:\Users\HTY\AppData\Roaming\Typora\typora-user-images\image-20210516172607737.png)



![image-20210516172621000](C:\Users\HTY\AppData\Roaming\Typora\typora-user-images\image-20210516172621000.png)